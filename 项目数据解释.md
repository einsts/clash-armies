# 分析一下这个项目，帮我解释一下军队列表(xxx.com/armies这个前端页面)的数据加载逻辑，重点疑问如下：
_Exported on 2025/9/5 at GMT+8 18:27:07 from Cursor (1.5.5)_

---

**User**

分析一下这个项目，帮我解释一下军队列表(xxx.com/armies这个前端页面)的数据加载逻辑，重点疑问如下：
1.军队列表在未点开时，展示的是哪些数据(英雄？法术？药水？宠物？装备？或者还有其它)
2.当前军队的容量/当前等级的最大容量如何计算，还有Spell 和siege容量的计算
3.添加英雄的原则，什么时候可以添加英雄，英雄的数量限制是多少，英雄还有装备和宠物，它们又能添加多少
4.什么时候有氏族城堡，氏族城堡是什么，为何有的军队有这个，有的没有


---

**Cursor**

I'll scan the `src/routes/armies` page components and related load functions to map how data is fetched and computed (capacities, heroes/pets/equipment, clan castle logic). Then I'll search shared utils/models for capacity and rules.

I'll open the main `armies` page files (`+page.server.ts` and `+page.svelte`) to see how data is loaded and displayed, then follow any referenced helpers for capacity, heroes, spells, siege, and clan castle rules.

I'll search the codebase for the army data model, capacity calculations, and clan castle logic referenced by `server.army.getArmies`, then open relevant files.

I'll open the `Armies/ArmyList.svelte` component and any related list item components to see what the collapsed view shows and how it renders units, heroes, pets, and equipment.

I'll open `ArmyCard.svelte` to see exactly what the collapsed list item renders (units, heroes, spells, pets, equipment), and then inspect `Army.svelte.ts` and `validation.ts` for capacity and rules (heroes/pets/equipment and clan castle).

I'll open the equipment validation to confirm limits for equipment per hero and pets per hero.

I’ve read the `/armies` page loader and UI components and traced capacity/validation rules in the shared models. Here are concise answers to your 4 questions with code pointers.

### 1) 军队卡片未展开时展示哪些数据
- 显示的主体单位列表是“军营(armyCamp)”里的单位：包括普通部队、法术、攻城器械，且顺序为“部队(普通→超级) → 法术 → 攻城器械”。
  ```16:21:src/components/UnitsList.svelte
  const selectedUnits = $derived(housedIn === 'armyCamp' ? model.units : model.ccUnits);
  const _troopUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Troop'));
  const troopUnits = $derived([..._troopUnits.filter((x) => !x.info.isSuper), ..._troopUnits.filter((x) => x.info.isSuper)]);
  const siegeUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Siege'));
  const spellUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Spell'));
  ```
- 卡片右上角显示当前“军营容量统计”(只展示军营，不包含氏族城堡)。
  ```66:73:src/components/ArmyCard.svelte
  <div class="bottom">
  	<ArmyTags {model} />
  	<UnitTotals {model} housedIn="armyCamp" />
  </div>
  <a href="/armies/{model.id}">
  	<UnitsList {model} {extraUnits} housedIn="armyCamp" display="block" />
  </a>
  ```
- “额外图标区”会显示：
  - 如果该军队配置了氏族城堡单位，则显示一个“城堡”图标；
  - 显示“已使用的英雄头像”。注意：这里“有无英雄”的判定来自是否给该英雄配置了装备或宠物（英雄自身并不单独存储）。
  ```28:41:src/components/ArmyCard.svelte
  {#snippet extraUnits()}
  	{#if model.ccUnits.length > 0}
  		<li class="clan-castle">
  			<img src="/ui/clan-castle.webp" alt="Clash of clans clan castle" title="Has clan castle" />
  		</li>
  	{/if}
  	{#each VALID_HEROES as hero}
  		{#if model.hasHero(hero)}
  			<li>
  				<HeroDisplay name={hero} />
  			</li>
  		{/if}
  	{/each}
  {/snippet}
  ```
- 不直接展示：宠物、装备的具体卡片；氏族城堡中的单位列表也不在列表卡片中展示。

### 2) 容量(当前/最大)的计算方式，包括 Spell 与 Siege
- 军营(armyCamp)的最大容量来自当前大本营等级的 `town_hall` 静态数据：`troopCapacity`/`spellCapacity`/`siegeCapacity`。
  ```187:195:src/lib/models/Army.svelte.ts
  public get capacity() {
  	const { troopCapacity, spellCapacity, siegeCapacity } = this.thData;
  	return { troops: troopCapacity, spells: spellCapacity, sieges: siegeCapacity };
  }
  ```
- 氏族城堡(clanCastle)的最大容量来自同一 `town_hall` 数据的 CC 字段：`ccTroopCapacity`/`ccSpellCapacity`/`ccSiegeCapacity`。
  ```192:195:src/lib/models/Army.svelte.ts
  public get ccCapacity() {
  	const { ccTroopCapacity, ccSpellCapacity, ccSiegeCapacity } = this.thData;
  	return { troops: ccTroopCapacity, spells: ccSpellCapacity, sieges: ccSiegeCapacity };
  }
  ```
- “已用容量”的计算：对所选单位的 `housingSpace * amount` 分别按类型累加，军营与城堡各自单独统计。
  ```82:90:src/lib/models/Unit.svelte.ts
  public static getTotals(units: UnitModel[]) {
  	return units.reduce(
  		(prev, curr) => {
  		 const key = (curr.info.type.toLowerCase() + 's') as 'troops' | 'sieges' | 'spells';
  		 prev[key] += curr.info.housingSpace * curr.amount;
  		 return prev;
  		},
  		{ troops: 0, sieges: 0, spells: 0 }
  	);
  }
  ```
- UI 显示：`UnitTotals` 会根据 `housedIn` 分别读军营或城堡的“已用/最大”。容量为 0 的类别不显示。
  ```11:13:src/components/UnitTotals.svelte
  const used = $derived(housedIn === 'armyCamp' ? model.housingSpaceUsed : model.ccHousingSpaceUsed);
  const capacity = $derived(housedIn === 'armyCamp' ? model.capacity : model.ccCapacity);
  ```
- 校验：保存前会校验已用不超过当前 TH 的最大容量（军营与城堡分别校验）。
  ```81:96:src/lib/shared/validation.ts
  if (housingSpaceUsed.troops > thData.troopCapacity) { ... }
  if (housingSpaceUsed.spells > thData.spellCapacity) { ... }
  if (housingSpaceUsed.sieges > thData.siegeCapacity) { ... }
  ```
  ```121:136:src/lib/shared/validation.ts
  if (ccHousingSpaceUsed.troops > thData.ccTroopCapacity) { ... }
  if (ccHousingSpaceUsed.spells > thData.ccSpellCapacity) { ... }
  if (ccHousingSpaceUsed.sieges > thData.ccSiegeCapacity) { ... }
  ```

### 3) 添加英雄的原则、数量限制，以及装备/宠物数量
- 何时可以“添加英雄”：实质上是给某个英雄“配置了装备或宠物”即视为该英雄被使用。若当前 TH 未解锁该英雄，则无法给该英雄配置东西（校验会报错）。
  ```283:291:src/lib/models/Army.svelte.ts
  public hasHero(hero: HeroType) {
  	if (this.equipment.find((eq) => eq.info.hero === hero)) { return true; }
  	if (this.pets.find((pet) => pet.hero === hero)) { return true; }
  	return false;
  }
  ```
  - UI 层：当 TH 低于首个英雄的解锁 TH 时，“添加英雄”入口会提示需要的最低 TH。
  ```12:16:src/components/AddHeroes.svelte
  const requiredThLvl = $derived.by(() => {
  	const kingThsLevel = app.townHalls.filter((th) => ArmyModel.getMaxHeroLevel('Barbarian King', th.level, app) !== -1).map((th) => th.level);
  	return Math.min(...kingThsLevel);
  });
  ```
- 英雄数量上限：最多 4 名（被认为“使用”的英雄数 = 至少有一件装备或一个宠物的英雄数量）。
  ```55:58:src/lib/shared/validation.ts
  const heroesUsed = VALID_HEROES.filter((hero) => hasHero(hero, model)).length;
  if (heroesUsed > 4) { throw new Error('Cannot use more than 4 heroes'); }
  ```
- 装备限制（按英雄）：
  - 单个英雄最多 2 件装备；同名装备不可重复；
  - 装备需要该英雄已在当前 TH 解锁，且该装备在当前 TH 可用。
  ```149:161:src/lib/shared/validation.ts
  const stashedEquipment = heroToEquipment[eq.info.hero] ?? [];
  if (stashedEquipment.includes(eq.info.name)) { ... }
  if (stashedEquipment.length === 2) {
  	throw new Error(`Hero ${hero} cannot have more than two pieces of equipment`);
  }
  if (ArmyModel.getMaxHeroLevel(eq.info.hero, model.townHall, model.gameData) === -1) { ... }
  if (EquipmentModel.getMaxLevel(eq.info.name, model.townHall, model.gameData) === -1) { ... }
  ```
- 宠物限制（按英雄）：
  - 单个英雄最多 1 只宠物；同一只宠物不能分配给两个不同英雄；
  - 宠物需要该英雄已在当前 TH 解锁，且宠物在当前 TH 可用。
  ```171:190:src/lib/shared/validation.ts
  const stashedPets = heroToPets[pet.hero] ?? [];
  if (stashedPets.length === 1) { throw new Error(`Hero ${hero} cannot have more than one pet`); }
  if (Object.values(heroToPets).flatMap((p) => p).includes(pet.info.name)) {
  	throw new Error(`Pet "${pet.info.name}" has already been assigned to another hero`);
  }
  if (ArmyModel.getMaxHeroLevel(pet.hero, model.townHall, model.gameData) === -1) { ... }
  if (PetModel.getMaxLevel(pet.info.name, model.townHall, model.gameData) === -1) { ... }
  ```

### 4) 氏族城堡(Clan Castle) 何时有、是什么、为何有些军队有有些没有
- “是什么”：一组独立于军营的单位槽位（可包含部队/法术/攻城器械），有独立容量限制；保存在 `model.ccUnits` 中，并按 CC 的容量字段单独统计与校验。
- “何时有”：当当前 TH 的 `maxCc` 非空时，才算解锁了氏族城堡功能；UI 上才会提供“添加城堡”的入口。
  ```12:15:src/components/AddClanCastle.svelte
  const ccUnlocked = $derived(model.thData.maxCc !== null);
  const ccMinThLevel = $derived(Math.min(...app.townHalls.filter((th) => th.maxCc !== null).map((th) => th.level)));
  ```
  - 具体某个 CC 单位能否使用，还会受 CC 实验室上限、单位自身规则限制（例如 Battle Drill 需要更高的 CC 等级）。
  ```187:195:src/lib/models/Unit.svelte.ts
  if (thData.maxCc === null || (name === 'Battle Drill' && thData.maxCc < 9)) {
  	return -1;
  }
  ```
- “为何有些军队有，有些没有”：即使 TH 已解锁 CC，也只有当创建者实际添加了 CC 单位时，列表卡片上才会显示“城堡图标”；未添加则不显示。
  ```28:33:src/components/ArmyCard.svelte
  {#if model.ccUnits.length > 0}
  	<li class="clan-castle">
  		<img src="/ui/clan-castle.webp" ... />
  	</li>
  {/if}
  ```

— 简短补充：数据来源
- `/armies` 由服务端 `getArmies` 取数（含单位/装备/宠物等），前端将其包进 `ArmyModel` 并渲染。
  ```3:6:src/routes/armies/+page.server.ts
  const server = req.locals.server;
  const armies = await server.army.getArmies(req);
  ```
- 列表中过滤/搜索、是否有 CC/是否有英雄等，均在前端基于 `ArmyModel` 的派生属性进行。

小结
- 列表卡片展示：军营中的部队/法术/攻城器械 + 顶部容量统计 + 英雄头像 +（可选）CC 图标；不直接展示宠物/装备/CC 具体单位。
- 容量=来自当前 TH 配置的上限；“已用”=单位 housingSpace×数量 的分类求和；军营与 CC 各自独立统计/校验。
- 英雄的“存在”=该英雄被分配了装备或宠物；最多 4 名英雄；每英雄最多 2 装备、1 宠物，且需在当前 TH 合规。
- CC 在 TH 解锁后才可添加；是否显示取决于是否真的给该军队添加了 CC 单位。

```plaintext
  const selectedUnits = $derived(housedIn === 'armyCamp' ? model.units : model.ccUnits);
  const _troopUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Troop'));
  const troopUnits = $derived([..._troopUnits.filter((x) => !x.info.isSuper), ..._troopUnits.filter((x) => x.info.isSuper)]);
  const siegeUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Siege'));
  const spellUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Spell'));
```

```plaintext
  <div class="bottom">
  	<ArmyTags {model} />
  	<UnitTotals {model} housedIn="armyCamp" />
  </div>
  <a href="/armies/{model.id}">
  	<UnitsList {model} {extraUnits} housedIn="armyCamp" display="block" />
  </a>
```

```plaintext
  {#snippet extraUnits()}
  	{#if model.ccUnits.length > 0}
  		<li class="clan-castle">
  			<img src="/ui/clan-castle.webp" alt="Clash of clans clan castle" title="Has clan castle" />
  		</li>
  	{/if}
  	{#each VALID_HEROES as hero}
  		{#if model.hasHero(hero)}
  			<li>
  				<HeroDisplay name={hero} />
  			</li>
  		{/if}
  	{/each}
  {/snippet}
```

```typescript
  public get capacity() {
  	const { troopCapacity, spellCapacity, siegeCapacity } = this.thData;
  	return { troops: troopCapacity, spells: spellCapacity, sieges: siegeCapacity };
  }
```

```typescript
  public get ccCapacity() {
  	const { ccTroopCapacity, ccSpellCapacity, ccSiegeCapacity } = this.thData;
  	return { troops: ccTroopCapacity, spells: ccSpellCapacity, sieges: ccSiegeCapacity };
  }
```

```typescript
  public static getTotals(units: UnitModel[]) {
  	return units.reduce(
  		(prev, curr) => {
  		 const key = (curr.info.type.toLowerCase() + 's') as 'troops' | 'sieges' | 'spells';
  		 prev[key] += curr.info.housingSpace * curr.amount;
  		 return prev;
  		},
  		{ troops: 0, sieges: 0, spells: 0 }
  	);
  }
```

```plaintext
  const used = $derived(housedIn === 'armyCamp' ? model.housingSpaceUsed : model.ccHousingSpaceUsed);
  const capacity = $derived(housedIn === 'armyCamp' ? model.capacity : model.ccCapacity);
```

```typescript
  if (housingSpaceUsed.troops > thData.troopCapacity) { ... }
  if (housingSpaceUsed.spells > thData.spellCapacity) { ... }
  if (housingSpaceUsed.sieges > thData.siegeCapacity) { ... }
```

```typescript
  if (ccHousingSpaceUsed.troops > thData.ccTroopCapacity) { ... }
  if (ccHousingSpaceUsed.spells > thData.ccSpellCapacity) { ... }
  if (ccHousingSpaceUsed.sieges > thData.ccSiegeCapacity) { ... }
```

```typescript
  public hasHero(hero: HeroType) {
  	if (this.equipment.find((eq) => eq.info.hero === hero)) { return true; }
  	if (this.pets.find((pet) => pet.hero === hero)) { return true; }
  	return false;
  }
```

```plaintext
  const requiredThLvl = $derived.by(() => {
  	const kingThsLevel = app.townHalls.filter((th) => ArmyModel.getMaxHeroLevel('Barbarian King', th.level, app) !== -1).map((th) => th.level);
  	return Math.min(...kingThsLevel);
  });
```

```typescript
  const heroesUsed = VALID_HEROES.filter((hero) => hasHero(hero, model)).length;
  if (heroesUsed > 4) { throw new Error('Cannot use more than 4 heroes'); }
```

```typescript
  const stashedEquipment = heroToEquipment[eq.info.hero] ?? [];
  if (stashedEquipment.includes(eq.info.name)) { ... }
  if (stashedEquipment.length === 2) {
  	throw new Error(`Hero ${hero} cannot have more than two pieces of equipment`);
  }
  if (ArmyModel.getMaxHeroLevel(eq.info.hero, model.townHall, model.gameData) === -1) { ... }
  if (EquipmentModel.getMaxLevel(eq.info.name, model.townHall, model.gameData) === -1) { ... }
```

```typescript
  const stashedPets = heroToPets[pet.hero] ?? [];
  if (stashedPets.length === 1) { throw new Error(`Hero ${hero} cannot have more than one pet`); }
  if (Object.values(heroToPets).flatMap((p) => p).includes(pet.info.name)) {
  	throw new Error(`Pet "${pet.info.name}" has already been assigned to another hero`);
  }
  if (ArmyModel.getMaxHeroLevel(pet.hero, model.townHall, model.gameData) === -1) { ... }
  if (PetModel.getMaxLevel(pet.info.name, model.townHall, model.gameData) === -1) { ... }
```

```plaintext
  const ccUnlocked = $derived(model.thData.maxCc !== null);
  const ccMinThLevel = $derived(Math.min(...app.townHalls.filter((th) => th.maxCc !== null).map((th) => th.level)));
```

```typescript
  if (thData.maxCc === null || (name === 'Battle Drill' && thData.maxCc < 9)) {
  	return -1;
  }
```

```plaintext
  {#if model.ccUnits.length > 0}
  	<li class="clan-castle">
  		<img src="/ui/clan-castle.webp" ... />
  	</li>
  {/if}
```

```typescript
  const server = req.locals.server;
  const armies = await server.army.getArmies(req);
```

---

**User**

将你上面的解释给我生成一个md文档吧

---

**Cursor**

### 军队列表 /armies 前端数据加载与规则说明

本文解释 `xxx.com/armies`（项目 `src/routes/armies`）页面的数据加载流程与军队列表（未展开卡片）展示逻辑，重点覆盖：
- 军队卡片未展开时展示的内容
- 容量（军营/法术/攻城器）的当前值与最大值如何计算
- 英雄、装备、宠物的添加原则与数量限制
- 氏族城堡的出现条件、含义与差异原因

---

### 页面数据加载概览

- 服务器端加载：页面从本地服务 `server.army.getArmies` 拉取军队数据，返回到前端渲染。
```3:6:src/routes/armies/+page.server.ts
export const load: PageServerLoad = async (req) => {
	const server = req.locals.server;
	const armies = await server.army.getArmies(req);
	return { armies };
};
```

- 列表渲染：`ArmyList` 将原始数据包装为 `ArmyModel`，并渲染卡片。
```33:39:src/components/Armies/ArmyList.svelte
const { data, bannerOptions, armiesPerPage = 10, allowSearch = false, allowTHFilter = false, allowFilters = false }: Props = $props();
const app = getContext<AppState>('app');
const armies = $derived.by(() => {
	return data.map((army) => {
		return untrack(() => new ArmyModel(app, army));
	});
});
```

- 后端返回包含单位/装备/宠物等聚合字段（节选）：
```86:103:src/lib/server/api/ArmyAPI.ts
public async getArmies(req: RequestEvent, options: GetArmiesOptions = {}) {
	...
	let query = `
		SELECT
			a.*,
			am.score,
			am.votes,
			am.pageViews,
			...
			au.units,
			ae.equipment,
			ap.pets,
			at.tags,
			ac.comments,
			IF(ag.id, JSON_OBJECT(
				'id', ag.id,
```

---

### 1) 军队卡片未展开时展示哪些数据

- 展示的“单位列表”来自军营（`armyCamp`）中的单位：包含普通部队、法术、攻城器械，且顺序为“部队(普通→超级) → 法术 → 攻城器械”。
```16:21:src/components/UnitsList.svelte
const selectedUnits = $derived(housedIn === 'armyCamp' ? model.units : model.ccUnits);
const _troopUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Troop'));
const troopUnits = $derived([..._troopUnits.filter((x) => !x.info.isSuper), ..._troopUnits.filter((x) => x.info.isSuper)]);
const siegeUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Siege'));
const spellUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Spell'));
```
```71:73:src/components/ArmyCard.svelte
<a href="/armies/{model.id}">
	<UnitsList {model} {extraUnits} housedIn="armyCamp" display="block" />
</a>
```

- 卡片顶部右侧显示“军营容量统计”（不包含氏族城堡）：
```66:69:src/components/ArmyCard.svelte
<div class="bottom">
	<ArmyTags {model} />
	<UnitTotals {model} housedIn="armyCamp" />
</div>
```

- 额外图标区：
  - 若军队配置了氏族城堡单位（`ccUnits` 非空），展示一个“城堡”图标；
  - 展示“已使用的英雄头像”。“有无英雄”的判定基于该英雄是否配置了装备或宠物（英雄本体不单独存库）。
```28:37:src/components/ArmyCard.svelte
{#if model.ccUnits.length > 0}
	<li class="clan-castle">
		<img src="/ui/clan-castle.webp" alt="Clash of clans clan castle" title="Has clan castle" />
	</li>
{/if}
{#each VALID_HEROES as hero}
	{#if model.hasHero(hero)}
		<li>
			<HeroDisplay name={hero} />
		</li>
	{/if}
{/each}
```

- 不会直接展示：宠物、装备的具体卡片；氏族城堡单位的具体列表。

---

### 2) 容量计算（军营/法术/攻城器），当前值与最大值

- 军营最大容量来自当前 TH 的静态数据：`troopCapacity` / `spellCapacity` / `siegeCapacity`。
```187:190:src/lib/models/Army.svelte.ts
public get capacity() {
	const { troopCapacity, spellCapacity, siegeCapacity } = this.thData;
	return { troops: troopCapacity, spells: spellCapacity, sieges: siegeCapacity };
}
```

- 氏族城堡最大容量：`ccTroopCapacity` / `ccSpellCapacity` / `ccSiegeCapacity`。
```192:195:src/lib/models/Army.svelte.ts
public get ccCapacity() {
	const { ccTroopCapacity, ccSpellCapacity, ccSiegeCapacity } = this.thData;
	return { troops: ccTroopCapacity, spells: ccSpellCapacity, sieges: ccSiegeCapacity };
}
```

- “已用容量”计算：对所选单位的 `housingSpace * amount` 按类别累加（军营/城堡分别统计）。
```82:90:src/lib/models/Unit.svelte.ts
public static getTotals(units: UnitModel[]) {
	return units.reduce(
		(prev, curr) => {
		 const key = (curr.info.type.toLowerCase() + 's') as 'troops' | 'sieges' | 'spells';
		 prev[key] += curr.info.housingSpace * curr.amount;
		 return prev;
		},
		{ troops: 0, sieges: 0, spells: 0 }
	);
}
```

- UI 展示（按 `housedIn` 选择军营或城堡）：
```11:13:src/components/UnitTotals.svelte
const used = $derived(housedIn === 'armyCamp' ? model.housingSpaceUsed : model.ccHousingSpaceUsed);
const capacity = $derived(housedIn === 'armyCamp' ? model.capacity : model.ccCapacity);
```

- 校验（保存前）：军营与城堡各自校验“已用 ≤ 最大”。
```81:96:src/lib/shared/validation.ts
if (housingSpaceUsed.troops > thData.troopCapacity) { ... }
if (housingSpaceUsed.spells > thData.spellCapacity) { ... }
if (housingSpaceUsed.sieges > thData.siegeCapacity) { ... }
```
```121:136:src/lib/shared/validation.ts
if (ccHousingSpaceUsed.troops > thData.ccTroopCapacity) { ... }
if (ccHousingSpaceUsed.spells > thData.ccSpellCapacity) { ... }
if (ccHousingSpaceUsed.sieges > thData.ccSiegeCapacity) { ... }
```

---

### 3) 英雄添加原则与数量限制；装备/宠物数量

- 何时算“添加了英雄”：当某英雄“被配置了至少一件装备或一个宠物”。若该英雄在当前 TH 未解锁，添加会被校验拒绝。
```283:291:src/lib/models/Army.svelte.ts
public hasHero(hero: HeroType) {
	if (this.equipment.find((eq) => eq.info.hero === hero)) {
		return true;
	}
	if (this.pets.find((pet) => pet.hero === hero)) {
		return true;
	}
	return false;
}
```

- 英雄数量上限：最多 4 名。
```55:58:src/lib/shared/validation.ts
const heroesUsed = VALID_HEROES.filter((hero) => hasHero(hero, model)).length;
if (heroesUsed > 4) {
	throw new Error('Cannot use more than 4 heroes');
}
```

- 装备限制（按英雄）：
  - 单个英雄最多 2 件装备；
  - 同名装备不可重复；
  - 要求该英雄与装备在当前 TH 可用。
```149:156:src/lib/shared/validation.ts
const stashedEquipment = heroToEquipment[eq.info.hero] ?? [];
if (stashedEquipment.includes(eq.info.name)) { ... }
if (stashedEquipment.length === 2) {
	throw new Error(`Hero ${hero} cannot have more than two pieces of equipment`);
}
```

- 宠物限制（按英雄）：
  - 单个英雄最多 1 只宠物；
  - 同一只宠物不可分配给两个英雄；
  - 要求英雄/宠物在当前 TH 可用。
```171:176:src/lib/shared/validation.ts
const stashedPets = heroToPets[pet.hero] ?? [];
	if (stashedPets.length === 1) {
		throw new Error(`Hero ${hero} cannot have more than one pet`);
	}
```
```178:183:src/lib/shared/validation.ts
if (Object.values(heroToPets).flatMap((p) => p).includes(pet.info.name)) {
	throw new Error(`Pet "${pet.info.name}" has already been assigned to another hero`);
}
```

- UI 引导：若 TH 未达到首位英雄解锁等级，按钮会提示所需最低 TH。
```12:16:src/components/AddHeroes.svelte
const requiredThLvl = $derived.by(() => {
	const kingThsLevel = app.townHalls.filter((th) => ArmyModel.getMaxHeroLevel('Barbarian King', th.level, app) !== -1).map((th) => th.level);
	return Math.min(...kingThsLevel);
});
```

---

### 4) 氏族城堡何时有、是什么、为何有的有有的没有

- 是什么：一组独立于军营的单位槽位（可包含部队/法术/攻城器械），保存在 `model.ccUnits`，有独立容量与校验。
- 何时可用：当当前 TH 的 `maxCc` 非空时，视为已解锁氏族城堡，UI 才提供“添加”入口。
```12:15:src/components/AddClanCastle.svelte
const ccUnlocked = $derived(model.thData.maxCc !== null);
const ccMinThLevel = $derived(Math.min(...app.townHalls.filter((th) => th.maxCc !== null).map((th) => th.level)));
```

- 个别单位的 CC 限制：如 Battle Drill 需要更高的城堡等级，未达到时不可用。
```192:195:src/lib/models/Unit.svelte.ts
if (thData.maxCc === null || (name === 'Battle Drill' && thData.maxCc < 9)) {
	return -1;
}
```

- 为何有的军队有、有的没有：即使 TH 已解锁 CC，也只有当作者实际添加了 CC 单位时，卡片才显示“城堡图标”；未添加则不显示。
```28:33:src/components/ArmyCard.svelte
{#if model.ccUnits.length > 0}
	<li class="clan-castle">
		<img src="/ui/clan-castle.webp" ... />
	</li>
{/if}
```

---

### 数据来源与类型要点

- TH 能力字段（含 CC 相关能力）来自 `town_halls` 静态/迁移数据，供 `ArmyModel.thData` 使用。
- 单位可用性与最大等级由 `UnitModel.getMaxLevel`/`getMaxCcLevel` 基于 TH 的建筑等级限制、实验室等级、产出建筑等综合计算。
- 列表过滤（是否有 CC/是否有英雄/无超级部队/无史诗装备等）在前端基于 `ArmyModel` 的派生属性完成。

---

如需将本文保存为项目内文档，告诉我目标路径与文件名（例如：`docs/armies-loading-rules.md`），我可以直接为你创建文件并提交。

```typescript
export const load: PageServerLoad = async (req) => {
	const server = req.locals.server;
	const armies = await server.army.getArmies(req);
	return { armies };
};
```

```plaintext
const { data, bannerOptions, armiesPerPage = 10, allowSearch = false, allowTHFilter = false, allowFilters = false }: Props = $props();
const app = getContext<AppState>('app');
const armies = $derived.by(() => {
	return data.map((army) => {
		return untrack(() => new ArmyModel(app, army));
	});
});
```

```typescript
public async getArmies(req: RequestEvent, options: GetArmiesOptions = {}) {
	...
	let query = `
		SELECT
			a.*,
			am.score,
			am.votes,
			am.pageViews,
			...
			au.units,
			ae.equipment,
			ap.pets,
			at.tags,
			ac.comments,
			IF(ag.id, JSON_OBJECT(
				'id', ag.id,
```

```plaintext
const selectedUnits = $derived(housedIn === 'armyCamp' ? model.units : model.ccUnits);
const _troopUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Troop'));
const troopUnits = $derived([..._troopUnits.filter((x) => !x.info.isSuper), ..._troopUnits.filter((x) => x.info.isSuper)]);
const siegeUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Siege'));
const spellUnits = $derived(selectedUnits.filter((unit) => unit.info.type === 'Spell'));
```

```plaintext
<a href="/armies/{model.id}">
	<UnitsList {model} {extraUnits} housedIn="armyCamp" display="block" />
</a>
```

```plaintext
<div class="bottom">
	<ArmyTags {model} />
	<UnitTotals {model} housedIn="armyCamp" />
</div>
```

```plaintext
{#if model.ccUnits.length > 0}
	<li class="clan-castle">
		<img src="/ui/clan-castle.webp" alt="Clash of clans clan castle" title="Has clan castle" />
	</li>
{/if}
{#each VALID_HEROES as hero}
	{#if model.hasHero(hero)}
		<li>
			<HeroDisplay name={hero} />
		</li>
	{/if}
{/each}
```

```typescript
public get capacity() {
	const { troopCapacity, spellCapacity, siegeCapacity } = this.thData;
	return { troops: troopCapacity, spells: spellCapacity, sieges: siegeCapacity };
}
```

```typescript
public get ccCapacity() {
	const { ccTroopCapacity, ccSpellCapacity, ccSiegeCapacity } = this.thData;
	return { troops: ccTroopCapacity, spells: ccSpellCapacity, sieges: ccSiegeCapacity };
}
```

```typescript
public static getTotals(units: UnitModel[]) {
	return units.reduce(
		(prev, curr) => {
		 const key = (curr.info.type.toLowerCase() + 's') as 'troops' | 'sieges' | 'spells';
		 prev[key] += curr.info.housingSpace * curr.amount;
		 return prev;
		},
		{ troops: 0, sieges: 0, spells: 0 }
	);
}
```

```plaintext
const used = $derived(housedIn === 'armyCamp' ? model.housingSpaceUsed : model.ccHousingSpaceUsed);
const capacity = $derived(housedIn === 'armyCamp' ? model.capacity : model.ccCapacity);
```

```typescript
if (housingSpaceUsed.troops > thData.troopCapacity) { ... }
if (housingSpaceUsed.spells > thData.spellCapacity) { ... }
if (housingSpaceUsed.sieges > thData.siegeCapacity) { ... }
```

```typescript
if (ccHousingSpaceUsed.troops > thData.ccTroopCapacity) { ... }
if (ccHousingSpaceUsed.spells > thData.ccSpellCapacity) { ... }
if (ccHousingSpaceUsed.sieges > thData.ccSiegeCapacity) { ... }
```

```typescript
public hasHero(hero: HeroType) {
	if (this.equipment.find((eq) => eq.info.hero === hero)) {
		return true;
	}
	if (this.pets.find((pet) => pet.hero === hero)) {
		return true;
	}
	return false;
}
```

```typescript
const heroesUsed = VALID_HEROES.filter((hero) => hasHero(hero, model)).length;
if (heroesUsed > 4) {
	throw new Error('Cannot use more than 4 heroes');
}
```

```typescript
const stashedEquipment = heroToEquipment[eq.info.hero] ?? [];
if (stashedEquipment.includes(eq.info.name)) { ... }
if (stashedEquipment.length === 2) {
	throw new Error(`Hero ${hero} cannot have more than two pieces of equipment`);
}
```

```typescript
const stashedPets = heroToPets[pet.hero] ?? [];
	if (stashedPets.length === 1) {
		throw new Error(`Hero ${hero} cannot have more than one pet`);
	}
```

```typescript
if (Object.values(heroToPets).flatMap((p) => p).includes(pet.info.name)) {
	throw new Error(`Pet "${pet.info.name}" has already been assigned to another hero`);
}
```

```plaintext
const requiredThLvl = $derived.by(() => {
	const kingThsLevel = app.townHalls.filter((th) => ArmyModel.getMaxHeroLevel('Barbarian King', th.level, app) !== -1).map((th) => th.level);
	return Math.min(...kingThsLevel);
});
```

```plaintext
const ccUnlocked = $derived(model.thData.maxCc !== null);
const ccMinThLevel = $derived(Math.min(...app.townHalls.filter((th) => th.maxCc !== null).map((th) => th.level)));
```

```typescript
if (thData.maxCc === null || (name === 'Battle Drill' && thData.maxCc < 9)) {
	return -1;
}
```

```plaintext
{#if model.ccUnits.length > 0}
	<li class="clan-castle">
		<img src="/ui/clan-castle.webp" ... />
	</li>
{/if}
```

